# æ°”ä½“æµ“åº¦æ£€æµ‹ç³»ç»Ÿå…¨é¢åˆ†æžæŠ¥å‘Š

## ðŸ“‹ ç›®å½•
1. [ç³»ç»Ÿæž¶æž„æ¦‚è§ˆ](#ç³»ç»Ÿæž¶æž„æ¦‚è§ˆ)
2. [æ–¹æ³•åŽŸç†è¯¦è§£](#æ–¹æ³•åŽŸç†è¯¦è§£)
3. [å…³é”®å‚æ•°åˆ†æž](#å…³é”®å‚æ•°åˆ†æž)
4. [ä»£ç æµç¨‹æ¢³ç†](#ä»£ç æµç¨‹æ¢³ç†)
5. [é—®é¢˜è¯†åˆ«ä¸Žåˆ†æž](#é—®é¢˜è¯†åˆ«ä¸Žåˆ†æž)
6. [æ€§èƒ½æå‡ç­–ç•¥](#æ€§èƒ½æå‡ç­–ç•¥)
7. [å®žé™…åº”ç”¨å»ºè®®](#å®žé™…åº”ç”¨å»ºè®®)

---

## ðŸ—ï¸ ç³»ç»Ÿæž¶æž„æ¦‚è§ˆ

### æ•´ä½“å·¥ä½œæµç¨‹
```
HITRANæ•°æ®åº“å…‰è°± â†’ æ•°æ®é¢„å¤„ç† â†’ ç‰¹å¾å·¥ç¨‹ â†’ PLSå»ºæ¨¡ â†’ æµ“åº¦é¢„æµ‹ â†’ ç»“æžœéªŒè¯
     â†“               â†“            â†“         â†“         â†“         â†“
  NO.csv          æ’å€¼ç»Ÿä¸€     æ³¢æ•°ç½‘æ ¼åŒ–   è®­ç»ƒå›žå½’    æ··åˆå…‰è°±   è¯¯å·®åˆ†æž
  NO2.csv         å™ªå£°å¤„ç†     æ ‡å‡†åŒ–å¤„ç†   äº¤å‰éªŒè¯    æµ“åº¦è¾“å‡º   æ€§èƒ½è¯„ä¼°
  SO2.csv         åŸºçº¿æ ¡æ­£     ç‰¹å¾é€‰æ‹©     æ¨¡åž‹ä¼˜åŒ–    ç½®ä¿¡åº¦     ç»“æžœå¯è§†åŒ–
```

### æ ¸å¿ƒç»„ä»¶
1. **æ•°æ®å±‚**: HITRANå…‰è°±æ•°æ®åº“
2. **é¢„å¤„ç†å±‚**: æ’å€¼ã€å½’ä¸€åŒ–ã€å™ªå£°å¤„ç†
3. **ç‰¹å¾å±‚**: ç»Ÿä¸€æ³¢æ•°ç½‘æ ¼ã€å…‰è°±å¼ºåº¦
4. **æ¨¡åž‹å±‚**: PLSå›žå½’ç®—æ³•
5. **åº”ç”¨å±‚**: æµ“åº¦é¢„æµ‹ã€ç»“æžœåˆ†æž

---

## ðŸ”¬ æ–¹æ³•åŽŸç†è¯¦è§£

### 1. åæœ€å°äºŒä¹˜æ³•(PLS)å›žå½’
```python
# æ ¸å¿ƒç®—æ³•
self.model = PLSRegression(n_components=5)
self.model.fit(X_train_scaled, Y_train.values)
```

**å·¥ä½œåŽŸç†**:
- **é™ç»´**: å°†é«˜ç»´å…‰è°±æ•°æ®æŠ•å½±åˆ°ä½Žç»´æ½œå˜é‡ç©ºé—´
- **å›žå½’**: åœ¨æ½œå˜é‡ç©ºé—´ä¸­å»ºç«‹ä¸Žæµ“åº¦çš„çº¿æ€§å…³ç³»
- **é¢„æµ‹**: é€šè¿‡åå‘å˜æ¢èŽ·å¾—æµ“åº¦é¢„æµ‹å€¼

**ä¼˜åŠ¿**:
- å¤„ç†é«˜ç»´æ•°æ®å’Œå¤šé‡å…±çº¿æ€§
- åŒæ—¶è€ƒè™‘X(å…‰è°±)å’ŒY(æµ“åº¦)çš„å˜å¼‚
- å¯¹å™ªå£°ç›¸å¯¹é²æ£’

**å±€é™æ€§**:
- å‡è®¾çº¿æ€§å…³ç³»
- éœ€è¦åˆé€‚çš„ä¸»æˆåˆ†æ•°é€‰æ‹©
- å¯¹å¼‚å¸¸å€¼æ•æ„Ÿ

### 2. å…‰è°±æ•°æ®å¤„ç†ç­–ç•¥

#### A. æ³¢æ•°ç»Ÿä¸€åŒ–
```python
# æ‰¾å…±åŒæ³¢æ•°èŒƒå›´
common_min = max(no_min, no2_min, so2_min)
common_max = min(no_max, no2_max, so2_max)

# åˆ›å»ºç»Ÿä¸€ç½‘æ ¼
wavenumber_grid = np.arange(np.ceil(common_min), np.floor(common_max) + 1, 1)
```

#### B. æ’å€¼å¤„ç†
```python
# çº¿æ€§æ’å€¼åˆ°ç»Ÿä¸€ç½‘æ ¼
interp_func = interp1d(wavenumbers, intensities, 
                      kind='linear', bounds_error=False, fill_value=0)
```

#### C. æ•°æ®æ ‡å‡†åŒ–
```python
# Z-scoreæ ‡å‡†åŒ–
self.scaler = StandardScaler()
X_train_scaled = self.scaler.fit_transform(X_train.values)
```

---

## âš™ï¸ å…³é”®å‚æ•°åˆ†æž

### 1. PLSæ¨¡åž‹å‚æ•°

| å‚æ•° | å½“å‰å€¼ | ä½œç”¨ | å½±å“ | ä¼˜åŒ–å»ºè®® |
|------|--------|------|------|----------|
| `n_components` | 5 | ä¸»æˆåˆ†æ•°é‡ | å†³å®šæ¨¡åž‹å¤æ‚åº¦ | ç”¨äº¤å‰éªŒè¯é€‰æ‹©æœ€ä¼˜å€¼ |
| `scale` | True | æ˜¯å¦æ ‡å‡†åŒ– | å½±å“ä¸åŒå°ºåº¦ç‰¹å¾çš„æƒé‡ | ä¿æŒTrue |
| `max_iter` | 500(é»˜è®¤) | æœ€å¤§è¿­ä»£æ¬¡æ•° | å½±å“æ”¶æ•›æ€§ | æ ¹æ®æ•°æ®é‡è°ƒæ•´ |

### 2. æ•°æ®é¢„å¤„ç†å‚æ•°

| å‚æ•° | å½“å‰å€¼ | è¯´æ˜Ž | å½±å“ | å»ºè®®è°ƒæ•´ |
|------|--------|------|------|----------|
| `step_size` | 1.0 cmâ»Â¹ | æ³¢æ•°ç½‘æ ¼é—´éš” | å½±å“æ•°æ®åˆ†è¾¨çŽ‡ | å¯æ”¹ä¸º0.5æé«˜ç²¾åº¦ |
| `noise_level` | 0.01 (1%) | å™ªå£°æ°´å¹³ | æ¨¡æ‹ŸçœŸå®žæµ‹é‡ | æ ¹æ®å®žé™…ä»ªå™¨è°ƒæ•´ |
| `fill_value` | 0 | æ’å€¼è¾¹ç•Œå¡«å…… | å¤„ç†å¤–æŽ¨åŒºåŸŸ | å¯å°è¯•è¾¹ç•Œå€¼å¡«å…… |

### 3. è®­ç»ƒæ•°æ®ç”Ÿæˆå‚æ•°

| å‚æ•° | å½“å‰å€¼ | è¯´æ˜Ž | ä¼˜åŒ–ç©ºé—´ |
|------|--------|------|----------|
| æµ“åº¦èŒƒå›´ | NO: 0.2-0.45, NO2: 0.3-0.55 | è®­ç»ƒæµ“åº¦èŒƒå›´ | æ‰©å¤§åˆ°0.05-0.95 |
| æ ·æœ¬æ•° | æ¯æ¯”ä¾‹10ä¸ª | æ¯ç§æ¯”ä¾‹çš„æ ·æœ¬æ•° | å¢žåŠ åˆ°50-100ä¸ª |
| å™ªå£°ç±»åž‹ | é«˜æ–¯å™ªå£° | å™ªå£°æ¨¡åž‹ | æ·»åŠ æ³Šæ¾å™ªå£°ã€ç³»ç»Ÿè¯¯å·® |

---

## ðŸ’» ä»£ç æµç¨‹æ¢³ç†

### é˜¶æ®µ1: æ•°æ®å‡†å¤‡ (`01_preprocess.py`)
```python
# æ ¸å¿ƒæ­¥éª¤
1. è¯»å–HITRANæ•°æ® â†’ æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
2. æ³¢æ•°èŒƒå›´åˆ†æž â†’ ç¡®å®šå…±åŒåŒºé—´
3. æ’å€¼ç»Ÿä¸€åŒ– â†’ ç”Ÿæˆç»Ÿä¸€ç½‘æ ¼
4. ä¿å­˜é¢„å¤„ç†ç»“æžœ
```

### é˜¶æ®µ2: è®­ç»ƒæ•°æ®ç”Ÿæˆ (`03_generate_dataset.py`)
```python
# æ•°æ®å¢žå¼ºç­–ç•¥
1. å¤šæ¯”ä¾‹ç»„åˆ â†’ è¦†ç›–æµ“åº¦ç©ºé—´
2. æ·»åŠ éšæœºå™ªå£° â†’ æé«˜é²æ£’æ€§
3. æ ·æœ¬é‡å¤ç”Ÿæˆ â†’ å¢žåŠ æ•°æ®é‡
4. æ ‡ç­¾å¯¹åº”ç”Ÿæˆ
```

### é˜¶æ®µ3: æ¨¡åž‹è®­ç»ƒ (`04b_pls_model_custom.py`)
```python
# ä¼˜åŒ–æµç¨‹
1. äº¤å‰éªŒè¯é€‰æ‹©ä¸»æˆåˆ†æ•°
2. æ•°æ®æ ‡å‡†åŒ–å¤„ç†
3. PLSæ¨¡åž‹è®­ç»ƒ
4. æ€§èƒ½è¯„ä¼°å’Œä¿å­˜
```

### é˜¶æ®µ4: å®žé™…æ£€æµ‹ (`spectrum_analyzer.py`)
```python
# é¢„æµ‹æµç¨‹
1. å…‰è°±æ•°æ®é¢„å¤„ç†
2. æ’å€¼åˆ°æ¨¡åž‹ç½‘æ ¼
3. æ ‡å‡†åŒ–è¾“å…¥
4. PLSé¢„æµ‹
5. ç»“æžœåŽå¤„ç†å’Œå¯è§†åŒ–
```

---

## âš ï¸ é—®é¢˜è¯†åˆ«ä¸Žåˆ†æž

### 1. æ•°æ®è´¨é‡é—®é¢˜

#### A. å…‰è°±è¦†ç›–åº¦ä¸è¶³
- **é—®é¢˜**: ä¸‰ç§æ°”ä½“çš„æ³¢æ•°èŒƒå›´å·®å¼‚è¾ƒå¤§
- **å½±å“**: æ’å€¼å¤–æŽ¨å¯¼è‡´ä¸å‡†ç¡®
- **è¡¨çŽ°**: å¤§é‡0å€¼å¡«å……ï¼Œæœ‰æ•ˆæ•°æ®ç‚¹ä¸è¶³

#### B. è®­ç»ƒæ•°æ®åˆ†å¸ƒé—®é¢˜
- **é—®é¢˜**: æµ“åº¦èŒƒå›´æœ‰é™ï¼Œæ ·æœ¬æ•°é‡ä¸è¶³
- **å½±å“**: æ¨¡åž‹æ³›åŒ–èƒ½åŠ›å·®
- **è¡¨çŽ°**: å¯¹è¾¹ç•Œæµ“åº¦é¢„æµ‹ä¸å‡†

### 2. æ¨¡åž‹è®¾è®¡é—®é¢˜

#### A. ä¸»æˆåˆ†æ•°é€‰æ‹©
```python
# å½“å‰æ–¹æ³•
pls = PLSRegression(n_components=5)  # å›ºå®šå€¼
```
- **é—®é¢˜**: æœªå……åˆ†ä¼˜åŒ–ä¸»æˆåˆ†æ•°
- **å½±å“**: å¯èƒ½è¿‡æ‹Ÿåˆæˆ–æ¬ æ‹Ÿåˆ

#### B. ç‰¹å¾å·¥ç¨‹ä¸è¶³
- **é—®é¢˜**: ä»…ä½¿ç”¨åŽŸå§‹å…‰è°±å¼ºåº¦
- **æœºä¼š**: å¯æ·»åŠ å¯¼æ•°ã€ç§¯åˆ†ç­‰ç‰¹å¾

### 3. éªŒè¯æ–¹æ³•é—®é¢˜

#### A. æ•°æ®æ³„æ¼é£Žé™©
- **é—®é¢˜**: è®­ç»ƒå’Œæµ‹è¯•æ•°æ®å¯èƒ½æœ‰ç›¸å…³æ€§
- **è§£å†³**: ç¡®ä¿å®Œå…¨ç‹¬ç«‹çš„éªŒè¯é›†

#### B. æ€§èƒ½è¯„ä¼°ä¸å…¨é¢
- **ç¼ºå¤±**: ç½®ä¿¡åŒºé—´ã€é²æ£’æ€§æµ‹è¯•
- **éœ€è¦**: å¤šç»´åº¦æ€§èƒ½è¯„ä¼°

### 4. å®žé™…åº”ç”¨é—®é¢˜

#### A. çœŸå®žå…‰è°±é€‚é…æ€§
- **é—®é¢˜**: è®­ç»ƒç”¨ä»¿çœŸæ•°æ®ï¼Œå®žé™…æ•°æ®å·®å¼‚å¤§
- **è¡¨çŽ°**: ä½ çš„22kv0h.CSVæ–‡ä»¶æ£€æµ‹å¼‚å¸¸

#### B. å™ªå£°æ¨¡åž‹ç®€åŒ–
- **é—®é¢˜**: ä»…è€ƒè™‘é«˜æ–¯å™ªå£°
- **çŽ°å®ž**: å®žé™…å™ªå£°æ›´å¤æ‚

---

## ðŸš€ æ€§èƒ½æå‡ç­–ç•¥

### 1. æ•°æ®å±‚é¢ä¼˜åŒ–

#### A. æ‰©å¤§è®­ç»ƒæ•°æ®é›†
```python
# æ”¹è¿›å»ºè®®
concentration_ranges = {
    'NO': np.arange(0.05, 0.95, 0.05),   # æ‰©å¤§èŒƒå›´
    'NO2': np.arange(0.05, 0.95, 0.05),
    'SO2': np.arange(0.05, 0.95, 0.05)
}
samples_per_combination = 50  # å¢žåŠ æ ·æœ¬æ•°
```

#### B. æ”¹è¿›å™ªå£°æ¨¡åž‹
```python
# å¤šç§å™ªå£°ç»„åˆ
gaussian_noise = np.random.normal(0, 0.01, spectrum.shape)
poisson_noise = np.random.poisson(spectrum * 1000) / 1000 - spectrum
systematic_drift = 0.001 * np.sin(wavenumbers * 0.01)
```

#### C. æ•°æ®å¢žå¼ºæŠ€æœ¯
```python
# å…‰è°±å˜æ¢
def augment_spectrum(spectrum, wavenumbers):
    # æ³¢é•¿æ¼‚ç§»
    shift = np.random.uniform(-0.5, 0.5)
    shifted_wn = wavenumbers + shift
    
    # å¼ºåº¦ç¼©æ”¾
    scale = np.random.uniform(0.95, 1.05)
    scaled_intensity = spectrum * scale
    
    # åŸºçº¿æ¼‚ç§»
    baseline = np.random.uniform(-0.001, 0.001)
    return scaled_intensity + baseline
```

### 2. æ¨¡åž‹å±‚é¢ä¼˜åŒ–

#### A. è‡ªé€‚åº”ä¸»æˆåˆ†é€‰æ‹©
```python
def optimize_components(X, Y, max_components=20):
    best_score = -np.inf
    best_n = 1
    
    for n in range(1, max_components + 1):
        pls = PLSRegression(n_components=n)
        scores = cross_val_score(pls, X, Y, cv=10, scoring='r2')
        
        if scores.mean() > best_score:
            best_score = scores.mean()
            best_n = n
    
    return best_n, best_score
```

#### B. ç‰¹å¾å·¥ç¨‹å¢žå¼º
```python
def extract_advanced_features(spectrum, wavenumbers):
    features = []
    
    # åŽŸå§‹å…‰è°±
    features.extend(spectrum)
    
    # ä¸€é˜¶å¯¼æ•°
    first_derivative = np.gradient(spectrum)
    features.extend(first_derivative)
    
    # äºŒé˜¶å¯¼æ•°
    second_derivative = np.gradient(first_derivative)
    features.extend(second_derivative)
    
    # ç§¯åˆ†ç‰¹å¾
    cumulative = np.cumsum(spectrum)
    features.extend(cumulative)
    
    return np.array(features)
```

#### C. é›†æˆå­¦ä¹ æ–¹æ³•
```python
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import Ridge

# å¤šæ¨¡åž‹é›†æˆ
models = {
    'PLS': PLSRegression(n_components=best_n),
    'RF': RandomForestRegressor(n_estimators=100),
    'Ridge': Ridge(alpha=1.0)
}

# åŠ æƒå¹³å‡é¢„æµ‹
ensemble_prediction = (0.5 * pls_pred + 
                      0.3 * rf_pred + 
                      0.2 * ridge_pred)
```

### 3. éªŒè¯å±‚é¢ä¼˜åŒ–

#### A. ä¸¥æ ¼çš„éªŒè¯ç­–ç•¥
```python
# åˆ†å±‚éªŒè¯
def stratified_validation(X, Y, test_size=0.2):
    # æ ¹æ®æµ“åº¦èŒƒå›´åˆ†å±‚
    concentration_bins = np.digitize(Y.sum(axis=1), 
                                   bins=np.linspace(0.8, 1.2, 5))
    
    return train_test_split(X, Y, test_size=test_size, 
                           stratify=concentration_bins, 
                           random_state=42)
```

#### B. é²æ£’æ€§æµ‹è¯•
```python
def robustness_test(model, X_base, noise_levels):
    results = {}
    
    for noise_level in noise_levels:
        noise = np.random.normal(0, noise_level, X_base.shape)
        X_noisy = X_base + noise
        
        predictions = model.predict(X_noisy)
        results[noise_level] = calculate_metrics(predictions)
    
    return results
```

### 4. å®žé™…åº”ç”¨ä¼˜åŒ–

#### A. åŸŸè‡ªé€‚åº”æŠ€æœ¯
```python
def domain_adaptation(model, real_spectra, simulated_spectra):
    # ç‰¹å¾å¯¹é½
    real_mean = np.mean(real_spectra, axis=0)
    sim_mean = np.mean(simulated_spectra, axis=0)
    
    # å‡å€¼æ ¡æ­£
    corrected_real = real_spectra - real_mean + sim_mean
    
    return corrected_real
```

#### B. åœ¨çº¿æ ¡å‡†æœºåˆ¶
```python
def online_calibration(model, known_samples):
    # ä½¿ç”¨å·²çŸ¥æ ·æœ¬è¿›è¡Œå®žæ—¶æ ¡å‡†
    correction_factors = {}
    
    for sample, true_conc in known_samples:
        pred_conc = model.predict(sample)
        correction_factors[true_conc] = true_conc / pred_conc
    
    return correction_factors
```

---

## ðŸ“Š ç»“æžœåˆ†æžä¸Žè¦æ±‚å¯¹æ¯”

### å½“å‰æ€§èƒ½è¯„ä¼°

#### ç†æƒ³æ¡ä»¶ä¸‹ (ä»¿çœŸæ•°æ®)
- âœ… **å‡†ç¡®æ€§**: RÂ² > 0.95, RMSE < 0.02
- âœ… **ç¨³å®šæ€§**: äº¤å‰éªŒè¯æ ‡å‡†å·® < 0.01
- âœ… **è¦†ç›–åº¦**: è®­ç»ƒèŒƒå›´å†…é¢„æµ‹è‰¯å¥½

#### å®žé™…æ¡ä»¶ä¸‹ (çœŸå®žæ•°æ®)
- âŒ **é€‚åº”æ€§**: çœŸå®žå…‰è°±æ£€æµ‹å¼‚å¸¸
- âŒ **é²æ£’æ€§**: å¯¹å™ªå£°æ•æ„Ÿ
- âš ï¸ **æ³›åŒ–æ€§**: è¶…å‡ºè®­ç»ƒèŒƒå›´æ€§èƒ½ä¸‹é™

### ä¸Žå®žé™…éœ€æ±‚çš„å·®è·

| æŒ‡æ ‡ | ç†æƒ³è¦æ±‚ | å½“å‰æ€§èƒ½ | å·®è·åˆ†æž |
|------|----------|----------|----------|
| æ£€æµ‹ç²¾åº¦ | Â±2% | Â±5% (ä»¿çœŸ) | ä»¿çœŸæ•°æ®è‰¯å¥½ |
| å“åº”æ—¶é—´ | <5ç§’ | <1ç§’ | æ»¡è¶³è¦æ±‚ |
| é²æ£’æ€§ | å™ªå£°Â±10% | å™ªå£°Â±5% | éœ€è¦æ”¹è¿› |
| é€‚åº”æ€§ | å¤šç§å…‰è°±ä»ª | é™å®šæ¡ä»¶ | äºŸéœ€æå‡ |

---

## ðŸŽ¯ å®žé™…åº”ç”¨å»ºè®®

### çŸ­æœŸæ”¹è¿› (1-2å‘¨)
1. **ä¼˜åŒ–ä¸»æˆåˆ†æ•°**: ä½¿ç”¨ç½‘æ ¼æœç´¢ + äº¤å‰éªŒè¯
2. **å¢žåŠ è®­ç»ƒæ•°æ®**: æ‰©å¤§æµ“åº¦èŒƒå›´å’Œæ ·æœ¬æ•°é‡
3. **æ”¹è¿›å™ªå£°æ¨¡åž‹**: æ·»åŠ å¤šç§å™ªå£°ç±»åž‹
4. **å®Œå–„éªŒè¯**: å»ºç«‹ç‹¬ç«‹çš„éªŒè¯æ•°æ®é›†

### ä¸­æœŸç›®æ ‡ (1-2ä¸ªæœˆ)
1. **ç‰¹å¾å·¥ç¨‹**: æ·»åŠ å…‰è°±å¯¼æ•°ã€ç§¯åˆ†ç‰¹å¾
2. **é›†æˆå­¦ä¹ **: ç»“åˆå¤šç§ç®—æ³•
3. **åŸŸé€‚åº”**: å¤„ç†ä»¿çœŸä¸ŽçœŸå®žæ•°æ®çš„å·®å¼‚
4. **åœ¨çº¿æ ¡å‡†**: å»ºç«‹å®žæ—¶æ ¡å‡†æœºåˆ¶

### é•¿æœŸè§„åˆ’ (3-6ä¸ªæœˆ)
1. **æ·±åº¦å­¦ä¹ **: æŽ¢ç´¢CNNã€Transformerç­‰æ–¹æ³•
2. **ç‰©ç†çº¦æŸ**: èžå…¥Beer-Lambertå®šå¾‹ç­‰ç‰©ç†çŸ¥è¯†
3. **å¤šå…‰è°±ä»ªé€‚é…**: å»ºç«‹é€šç”¨çš„å…‰è°±å¤„ç†æ¡†æž¶
4. **å®žæ—¶ç³»ç»Ÿ**: å¼€å‘å®Œæ•´çš„åœ¨çº¿æ£€æµ‹ç³»ç»Ÿ

### ç«‹å³å¯æ‰§è¡Œçš„æ”¹è¿›
```python
# 1. ä¼˜åŒ–ä¸»æˆåˆ†æ•°
n_components = optimize_pls_components(X_train, Y_train)

# 2. å¢žåŠ éªŒè¯ä¸¥æ ¼æ€§
X_train, X_val, Y_train, Y_val = stratified_train_test_split(X, Y)

# 3. æ”¹è¿›é¢„å¤„ç†
def robust_preprocess(spectrum):
    # åŸºçº¿æ ¡æ­£
    spectrum = baseline_correction(spectrum)
    # å¹³æ»‘å¤„ç†
    spectrum = savgol_filter(spectrum, 11, 3)
    # å½’ä¸€åŒ–
    spectrum = (spectrum - spectrum.mean()) / spectrum.std()
    return spectrum
```

---

## ðŸ“ˆ æ€»ç»“ä¸Žå»ºè®®

### æ ¸å¿ƒé—®é¢˜
1. **æ•°æ®åŸŸå·®å¼‚**: ä»¿çœŸä¸ŽçœŸå®žæ•°æ®ä¸åŒ¹é…
2. **æ¨¡åž‹ç®€åŒ–**: PLSçº¿æ€§å‡è®¾çš„å±€é™æ€§
3. **éªŒè¯ä¸è¶³**: ç¼ºä¹çœŸå®žæ¡ä»¶ä¸‹çš„æµ‹è¯•

### ä¼˜å…ˆæ”¹è¿›æ–¹å‘
1. ðŸ¥‡ **æ•°æ®è´¨é‡**: æ”¶é›†æ›´å¤šçœŸå®žå…‰è°±æ•°æ®
2. ðŸ¥ˆ **æ¨¡åž‹é²æ£’æ€§**: æ”¹è¿›å™ªå£°å¤„ç†å’Œå¼‚å¸¸æ£€æµ‹
3. ðŸ¥‰ **éªŒè¯ä½“ç³»**: å»ºç«‹æ ‡å‡†åŒ–çš„æ€§èƒ½è¯„ä¼°

### æˆåŠŸå…³é”®
- **è¿­ä»£ä¼˜åŒ–**: æŒç»­æ”¹è¿›æ¨¡åž‹å’Œæ•°æ®
- **å®žé™…éªŒè¯**: åœ¨çœŸå®žçŽ¯å¢ƒä¸­æµ‹è¯•
- **é¢†åŸŸçŸ¥è¯†**: ç»“åˆå…‰è°±å­¦ç†è®ºæŒ‡å¯¼

å½“å‰ç³»ç»Ÿåœ¨ä»¿çœŸçŽ¯å¢ƒä¸‹è¡¨çŽ°è‰¯å¥½ï¼Œä½†åœ¨å®žé™…åº”ç”¨ä¸­éœ€è¦æ˜¾è‘—æ”¹è¿›ã€‚å»ºè®®ä¼˜å…ˆè§£å†³æ•°æ®é€‚åº”æ€§é—®é¢˜ï¼Œç„¶åŽé€æ­¥ä¼˜åŒ–æ¨¡åž‹æ€§èƒ½ã€‚